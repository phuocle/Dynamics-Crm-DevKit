//---------------------------------------------------------------------------------------------------
// <auto-generated>
//		Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
//		Generated by DynamicsCrm.DevKit - https://github.com/phuocle/Dynamics-Crm-DevKit
// </auto-generated>
//---------------------------------------------------------------------------------------------------
using Microsoft.Xrm.Sdk;
using System;
using System.Diagnostics;

namespace Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets
{
	public enum ExpansionStateCode
	{
		/// <summary>
		/// Full = 2
		/// </summary>
		Full = 2,
		/// <summary>
		/// Partial = 1
		/// </summary>
		Partial = 1,
		/// <summary>
		/// Unexpanded = 0
		/// </summary>
		Unexpanded = 0
	}

	public enum Instance
	{
		/// <summary>
		/// First = 1
		/// </summary>
		First = 1,
		/// <summary>
		/// Fourth = 4
		/// </summary>
		Fourth = 4,
		/// <summary>
		/// Last = 5
		/// </summary>
		Last = 5,
		/// <summary>
		/// Second = 2
		/// </summary>
		Second = 2,
		/// <summary>
		/// Third = 3
		/// </summary>
		Third = 3
	}

	public enum InstanceTypeCode
	{
		/// <summary>
		/// Not_Recurring = 0
		/// </summary>
		Not_Recurring = 0,
		/// <summary>
		/// Recurring_Exception = 3
		/// </summary>
		Recurring_Exception = 3,
		/// <summary>
		/// Recurring_Future_Exception = 4
		/// </summary>
		Recurring_Future_Exception = 4,
		/// <summary>
		/// Recurring_Instance = 2
		/// </summary>
		Recurring_Instance = 2,
		/// <summary>
		/// Recurring_Master = 1
		/// </summary>
		Recurring_Master = 1
	}

	public enum MonthOfYear
	{
		/// <summary>
		/// April = 4
		/// </summary>
		April = 4,
		/// <summary>
		/// August = 8
		/// </summary>
		August = 8,
		/// <summary>
		/// December = 12
		/// </summary>
		December = 12,
		/// <summary>
		/// February = 2
		/// </summary>
		February = 2,
		/// <summary>
		/// Invalid_Month_Of_Year = 0
		/// </summary>
		Invalid_Month_Of_Year = 0,
		/// <summary>
		/// January = 1
		/// </summary>
		January = 1,
		/// <summary>
		/// July = 7
		/// </summary>
		July = 7,
		/// <summary>
		/// June = 6
		/// </summary>
		June = 6,
		/// <summary>
		/// March = 3
		/// </summary>
		March = 3,
		/// <summary>
		/// May = 5
		/// </summary>
		May = 5,
		/// <summary>
		/// November = 11
		/// </summary>
		November = 11,
		/// <summary>
		/// October = 10
		/// </summary>
		October = 10,
		/// <summary>
		/// September = 9
		/// </summary>
		September = 9
	}

	public enum PatternEndType
	{
		/// <summary>
		/// No_End_Date = 1
		/// </summary>
		No_End_Date = 1,
		/// <summary>
		/// Occurrences = 2
		/// </summary>
		Occurrences = 2,
		/// <summary>
		/// Pattern_End_Date = 3
		/// </summary>
		Pattern_End_Date = 3
	}

	public enum PriorityCode
	{
		/// <summary>
		/// High = 2
		/// </summary>
		High = 2,
		/// <summary>
		/// Low = 0
		/// </summary>
		Low = 0,
		/// <summary>
		/// Normal = 1
		/// </summary>
		Normal = 1
	}

	public enum RecurrencePatternType
	{
		/// <summary>
		/// Daily = 0
		/// </summary>
		Daily = 0,
		/// <summary>
		/// Monthly = 2
		/// </summary>
		Monthly = 2,
		/// <summary>
		/// Weekly = 1
		/// </summary>
		Weekly = 1,
		/// <summary>
		/// Yearly = 3
		/// </summary>
		Yearly = 3
	}

	public enum StateCode
	{
		/// <summary>
		/// Canceled = 2
		/// </summary>
		Canceled = 2,
		/// <summary>
		/// Completed = 1
		/// </summary>
		Completed = 1,
		/// <summary>
		/// Open = 0
		/// </summary>
		Open = 0,
		/// <summary>
		/// Scheduled = 3
		/// </summary>
		Scheduled = 3
	}

	public enum StatusCode
	{
		/// <summary>
		/// Busy = 5
		/// </summary>
		Busy = 5,
		/// <summary>
		/// Canceled = 4
		/// </summary>
		Canceled = 4,
		/// <summary>
		/// Completed = 3
		/// </summary>
		Completed = 3,
		/// <summary>
		/// Free = 1
		/// </summary>
		Free = 1,
		/// <summary>
		/// Out_of_Office = 6
		/// </summary>
		Out_of_Office = 6,
		/// <summary>
		/// Tentative = 2
		/// </summary>
		Tentative = 2
	}
}

namespace Dev.DevKit.Shared.Entities
{
	public partial class RecurringAppointmentMaster : EntityBase
	{
		public struct Fields
		{
			public const string ActivityId = "activityid";
			public const string ActivityTypeCode = "activitytypecode";
			public const string Category = "category";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedOnBehalfBy = "createdonbehalfby";
			public const string DayOfMonth = "dayofmonth";
			public const string DaysOfWeekMask = "daysofweekmask";
			public const string DeletedExceptionsList = "deletedexceptionslist";
			public const string Description = "description";
			public const string Duration = "duration";
			public const string EffectiveEndDate = "effectiveenddate";
			public const string EffectiveStartDate = "effectivestartdate";
			public const string EndTime = "endtime";
			public const string ExchangeRate = "exchangerate";
			public const string ExpansionStateCode = "expansionstatecode";
			public const string FirstDayOfWeek = "firstdayofweek";
			public const string GlobalObjectId = "globalobjectid";
			public const string GroupId = "groupid";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string Instance = "instance";
			public const string InstanceTypeCode = "instancetypecode";
			public const string Interval = "interval";
			public const string IsAllDayEvent = "isalldayevent";
			public const string IsBilled = "isbilled";
			public const string IsMapiPrivate = "ismapiprivate";
			public const string IsNthMonthly = "isnthmonthly";
			public const string IsNthYearly = "isnthyearly";
			public const string IsRegenerate = "isregenerate";
			public const string IsRegularActivity = "isregularactivity";
			public const string IsUnsafe = "isunsafe";
			public const string IsWeekDayPattern = "isweekdaypattern";
			public const string IsWorkflowCreated = "isworkflowcreated";
			public const string LastExpandedInstanceDate = "lastexpandedinstancedate";
			public const string Location = "location";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedOnBehalfBy = "modifiedonbehalfby";
			public const string MonthOfYear = "monthofyear";
			public const string NextExpansionInstanceDate = "nextexpansioninstancedate";
			public const string Occurrences = "occurrences";
			public const string OptionalAttendees = "optionalattendees";
			public const string Organizer = "organizer";
			public const string OutlookOwnerApptId = "outlookownerapptid";
			public const string OverriddenCreatedOn = "overriddencreatedon";
			public const string OwnerId = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string PatternEndDate = "patternenddate";
			public const string PatternEndType = "patternendtype";
			public const string PatternStartDate = "patternstartdate";
			public const string PriorityCode = "prioritycode";
			public const string ProcessId = "processid";
			public const string RecurrencePatternType = "recurrencepatterntype";
			public const string RegardingObjectId = "regardingobjectid";
			public const string RequiredAttendees = "requiredattendees";
			public const string RuleId = "ruleid";
			public const string ScheduledEnd = "scheduledend";
			public const string ScheduledStart = "scheduledstart";
			public const string SeriesStatus = "seriesstatus";
			public const string SortDate = "sortdate";
			public const string StageId = "stageid";
			public const string StartTime = "starttime";
			public const string StateCode = "statecode";
			public const string StatusCode = "statuscode";
			public const string Subcategory = "subcategory";
			public const string Subject = "subject";
			public const string SubscriptionId = "subscriptionid";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string TransactionCurrencyId = "transactioncurrencyid";
			public const string TraversedPath = "traversedpath";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";
		}

		public const string EntityLogicalName = "recurringappointmentmaster";

		public const int EntityTypeCode = 4251;

		[DebuggerNonUserCode()]
		public RecurringAppointmentMaster()
		{
			Entity = new Entity(EntityLogicalName);
			PreEntity = CloneThisEntity(Entity);
		}

		[DebuggerNonUserCode()]
		public RecurringAppointmentMaster(Guid RecurringAppointmentMasterId)
		{
			Entity = new Entity(EntityLogicalName, RecurringAppointmentMasterId);
			PreEntity = CloneThisEntity(Entity);
		}

		[DebuggerNonUserCode()]
		public RecurringAppointmentMaster(string keyName, object keyValue)
		{
			Entity = new Entity(EntityLogicalName, keyName, keyValue);
			PreEntity = CloneThisEntity(Entity);
		}

		[DebuggerNonUserCode()]
		public RecurringAppointmentMaster(Entity entity)
		{
			Entity = entity;
			PreEntity = CloneThisEntity(Entity);
		}

		[DebuggerNonUserCode()]
		public RecurringAppointmentMaster(Entity entity, Entity merge)
		{
			Entity = entity;
			foreach (var property in merge?.Attributes)
			{
				var key = property.Key;
				var value = property.Value;
				Entity[key] = value;
			}
			PreEntity = CloneThisEntity(Entity);
		}

		[DebuggerNonUserCode()]
		public RecurringAppointmentMaster(KeyAttributeCollection keys)
		{
			Entity = new Entity(EntityLogicalName, keys);
			PreEntity = CloneThisEntity(Entity);
		}

		/// <summary>
		/// <para>Unique identifier of the recurring appointment series.</para>
		/// <para>Uniqueidentifier</para>
		/// <para>Recurring Appointment</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Guid? ActivityId
		{
			get { return Entity.GetAttributeValue<Guid?>(Fields.ActivityId); }
			set { Entity.Attributes[Fields.ActivityId] = value; }
		}

		/// <summary>
		/// <para>Type of activity.</para>
		/// <para>ReadOnly - EntityName</para>
		/// <para>Activity Type</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string ActivityTypeCode
		{
			get { return Entity.GetAttributeValue<string>(Fields.ActivityTypeCode); }
		}

		/// <summary>
		/// <para>Type a category to identify the recurring appointment type, such as status meeting or service call, to tie the appointment to a business group or function.</para>
		/// <para>String - MaxLength: 250</para>
		/// <para>Category</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string Category
		{
			get { return Entity.GetAttributeValue<string>(Fields.Category); }
			set { Entity.Attributes[Fields.Category] = value; }
		}

		/// <summary>
		/// <para>Shows who created the record.</para>
		/// <para>ReadOnly - Lookup to systemuser</para>
		/// <para>Created By</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference CreatedBy
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.CreatedBy); }
		}

		/// <summary>
		/// <para>Shows the date and time when the record was created. The date and time are displayed in the time zone selected in Microsoft Dynamics 365 options.</para>
		/// <para>ReadOnly - DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Created On</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? CreatedOnUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.CreatedOn); }
		}

		/// <summary>
		/// <para>Shows who created the record on behalf of another user.</para>
		/// <para>ReadOnly - Lookup to systemuser</para>
		/// <para>Created By (Delegate)</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference CreatedOnBehalfBy
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.CreatedOnBehalfBy); }
		}

		/// <summary>
		/// <para>The day of the month on which the recurring appointment occurs.</para>
		/// <para>Integer - MinValue: 1 - MaxValue: 31</para>
		/// <para>Day Of Month</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? DayOfMonth
		{
			get { return Entity.GetAttributeValue<int?>(Fields.DayOfMonth); }
			set { Entity.Attributes[Fields.DayOfMonth] = value; }
		}

		/// <summary>
		/// <para>Bitmask that represents the days of the week on which the recurring appointment occurs.</para>
		/// <para>Integer - MinValue: 1 - MaxValue: 127</para>
		/// <para>Days Of Week Mask</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? DaysOfWeekMask
		{
			get { return Entity.GetAttributeValue<int?>(Fields.DaysOfWeekMask); }
			set { Entity.Attributes[Fields.DaysOfWeekMask] = value; }
		}

		/// <summary>
		/// <para>List of deleted instances of the recurring appointment series.</para>
		/// <para>ReadOnly - Memo - MaxLength: 1073741823</para>
		/// <para>Deleted Appointments</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string DeletedExceptionsList
		{
			get { return Entity.GetAttributeValue<string>(Fields.DeletedExceptionsList); }
		}

		/// <summary>
		/// <para>Type additional information to describe the recurring appointment, such as key talking points or objectives.</para>
		/// <para>Memo - MaxLength: 1048576</para>
		/// <para>Description</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string Description
		{
			get { return Entity.GetAttributeValue<string>(Fields.Description); }
			set { Entity.Attributes[Fields.Description] = value; }
		}

		/// <summary>
		/// <para>Duration of the recurring appointment series in minutes.</para>
		/// <para>Integer - MinValue: 0 - MaxValue: 2,147,483,647</para>
		/// <para>Duration</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? Duration
		{
			get { return Entity.GetAttributeValue<int?>(Fields.Duration); }
			set { Entity.Attributes[Fields.Duration] = value; }
		}

		/// <summary>
		/// <para>Actual end date of the recurring appointment series based on the specified end date and recurrence pattern.</para>
		/// <para>DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Effective End Date</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? EffectiveEndDateUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.EffectiveEndDate); }
			set { Entity.Attributes[Fields.EffectiveEndDate] = value; }
		}

		/// <summary>
		/// <para>Actual start date of the recurring appointment series based on the specified start date and recurrence pattern.</para>
		/// <para>DateTimeBehavior: UserLocal - DateTimeFormat: DateOnly</para>
		/// <para>Effective Start Date</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? EffectiveStartDateUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.EffectiveStartDate); }
			set { Entity.Attributes[Fields.EffectiveStartDate] = value; }
		}

		/// <summary>
		/// <para>End time of the associated activity.</para>
		/// <para>DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Pattern End Time</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? EndTimeUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.EndTime); }
			set { Entity.Attributes[Fields.EndTime] = value; }
		}

		/// <summary>
		/// <para>Shows the conversion rate of the record's currency. The exchange rate is used to convert all money fields in the record from the local currency to the system's default currency.</para>
		/// <para>ReadOnly - Decimal - MinValue: 0 - MaxValue: 100,000,000,000</para>
		/// <para>Exchange Rate</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public decimal? ExchangeRate
		{
			get { return Entity.GetAttributeValue<decimal?>(Fields.ExchangeRate); }
		}

		/// <summary>
		/// <para>State code to indicate whether the recurring appointment series is expanded fully or partially.</para>
		/// <para>ReadOnly - Picklist</para>
		/// <para>Expansion State Code</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.ExpansionStateCode? ExpansionStateCode
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.ExpansionStateCode);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.ExpansionStateCode)value.Value;
			}
		}

		/// <summary>
		/// <para>First day of week for the recurrence pattern.</para>
		/// <para>Integer - MinValue: 0 - MaxValue: 6</para>
		/// <para>First Day Of Week</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? FirstDayOfWeek
		{
			get { return Entity.GetAttributeValue<int?>(Fields.FirstDayOfWeek); }
			set { Entity.Attributes[Fields.FirstDayOfWeek] = value; }
		}

		/// <summary>
		/// <para>Unique Outlook identifier to correlate recurring appointment series across Exchange mailboxes.</para>
		/// <para>String - MaxLength: 300</para>
		/// <para>Outlook Recurring Appointment Master</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string GlobalObjectId
		{
			get { return Entity.GetAttributeValue<string>(Fields.GlobalObjectId); }
			set { Entity.Attributes[Fields.GlobalObjectId] = value; }
		}

		/// <summary>
		/// <para>Unique identifier of the recurring appointment series for which the recurrence information was updated.</para>
		/// <para>ReadOnly - Lookup to recurringappointmentmaster</para>
		/// <para>Group Id</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference GroupId
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.GroupId); }
		}

		/// <summary>
		/// <para>Unique identifier of the data import or data migration that created this record.</para>
		/// <para>Integer - MinValue: -2,147,483,648 - MaxValue: 2,147,483,647</para>
		/// <para>Import Sequence Number</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? ImportSequenceNumber
		{
			get { return Entity.GetAttributeValue<int?>(Fields.ImportSequenceNumber); }
			set { Entity.Attributes[Fields.ImportSequenceNumber] = value; }
		}

		/// <summary>
		/// <para>Specifies the recurring appointment series to occur on every Nth day of a month. Valid for monthly and yearly recurrence patterns only.</para>
		/// <para>Picklist</para>
		/// <para>Instance</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.Instance? Instance
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.Instance);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.Instance)value.Value;
			}
			set
			{
				if (value.HasValue)
					Entity.Attributes[Fields.Instance] = new OptionSetValue((int)value.Value);
				else
					Entity.Attributes[Fields.Instance] = null;
			}
		}

		/// <summary>
		/// <para>Type of instance of a recurring appointment series.</para>
		/// <para>ReadOnly - Picklist</para>
		/// <para>Appointment Type</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.InstanceTypeCode? InstanceTypeCode
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.InstanceTypeCode);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.InstanceTypeCode)value.Value;
			}
		}

		/// <summary>
		/// <para>Number of units of a given recurrence type between occurrences.</para>
		/// <para>Integer - MinValue: 1 - MaxValue: 1,000</para>
		/// <para>Interval</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? Interval
		{
			get { return Entity.GetAttributeValue<int?>(Fields.Interval); }
			set { Entity.Attributes[Fields.Interval] = value; }
		}

		/// <summary>
		/// <para>Select whether the recurring appointment is an all-day event to make sure that the required resources are scheduled for the full day.</para>
		/// <para>Boolean</para>
		/// <para>All Day Event</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsAllDayEvent
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsAllDayEvent); }
			set { Entity.Attributes[Fields.IsAllDayEvent] = value; }
		}

		/// <summary>
		/// <para>Indicates whether the recurring appointment series was billed as part of resolving a case.</para>
		/// <para>Boolean</para>
		/// <para>Is Billed</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsBilled
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsBilled); }
			set { Entity.Attributes[Fields.IsBilled] = value; }
		}

		/// <summary>
		/// <para>For internal use only.</para>
		/// <para>Boolean</para>
		/// <para>Is Private</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsMapiPrivate
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsMapiPrivate); }
			set { Entity.Attributes[Fields.IsMapiPrivate] = value; }
		}

		/// <summary>
		/// <para>Indicates whether the recurring appointment series should occur after every N months. Valid for monthly recurrence pattern only.</para>
		/// <para>Boolean</para>
		/// <para>Nth Monthly</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsNthMonthly
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsNthMonthly); }
			set { Entity.Attributes[Fields.IsNthMonthly] = value; }
		}

		/// <summary>
		/// <para>Indicates whether the recurring appointment series should occur after every N years. Valid for yearly recurrence pattern only.</para>
		/// <para>Boolean</para>
		/// <para>Nth Yearly</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsNthYearly
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsNthYearly); }
			set { Entity.Attributes[Fields.IsNthYearly] = value; }
		}

		/// <summary>
		/// <para>For internal use only.</para>
		/// <para>Boolean</para>
		/// <para>Regenerate</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsRegenerate
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsRegenerate); }
			set { Entity.Attributes[Fields.IsRegenerate] = value; }
		}

		/// <summary>
		/// <para>Indicates whether the activity is a regular activity type or event type.</para>
		/// <para>ReadOnly - Boolean</para>
		/// <para>Is Regular Activity</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsRegularActivity
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsRegularActivity); }
		}

		/// <summary>
		/// <para>For internal use only.</para>
		/// <para>ReadOnly - Integer - MinValue: 0 - MaxValue: 2,147,483,647</para>
		/// <para>IsUnsafe</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? IsUnsafe
		{
			get { return Entity.GetAttributeValue<int?>(Fields.IsUnsafe); }
		}

		/// <summary>
		/// <para>Indicates whether the weekly recurrence pattern is a daily weekday pattern. Valid for weekly recurrence pattern only.</para>
		/// <para>Boolean</para>
		/// <para>Every Weekday</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsWeekDayPattern
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsWeekDayPattern); }
			set { Entity.Attributes[Fields.IsWeekDayPattern] = value; }
		}

		/// <summary>
		/// <para>Indicates whether the recurring appointment series was created from a workflow rule.</para>
		/// <para>Boolean</para>
		/// <para>Is Workflow Created</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? IsWorkflowCreated
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.IsWorkflowCreated); }
			set { Entity.Attributes[Fields.IsWorkflowCreated] = value; }
		}

		/// <summary>
		/// <para>Date of last expanded instance of a recurring appointment series.</para>
		/// <para>ReadOnly - DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Last Expanded Instance Date</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? LastExpandedInstanceDateUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.LastExpandedInstanceDate); }
		}

		/// <summary>
		/// <para>Type the location where the recurring appointment will take place, such as a conference room or customer office.</para>
		/// <para>String - MaxLength: 200</para>
		/// <para>Location</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string Location
		{
			get { return Entity.GetAttributeValue<string>(Fields.Location); }
			set { Entity.Attributes[Fields.Location] = value; }
		}

		/// <summary>
		/// <para>Shows who last updated the record.</para>
		/// <para>ReadOnly - Lookup to systemuser</para>
		/// <para>Modified By</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference ModifiedBy
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.ModifiedBy); }
		}

		/// <summary>
		/// <para>Shows the date and time when the record was last updated. The date and time are displayed in the time zone selected in Microsoft Dynamics 365 options.</para>
		/// <para>ReadOnly - DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Modified On</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? ModifiedOnUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.ModifiedOn); }
		}

		/// <summary>
		/// <para>Shows who last updated the record on behalf of another user.</para>
		/// <para>ReadOnly - Lookup to systemuser</para>
		/// <para>Modified By (Delegate)</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference ModifiedOnBehalfBy
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.ModifiedOnBehalfBy); }
		}

		/// <summary>
		/// <para>Indicates the month of the year for the recurrence pattern.</para>
		/// <para>Picklist</para>
		/// <para>Month Of Year</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.MonthOfYear? MonthOfYear
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.MonthOfYear);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.MonthOfYear)value.Value;
			}
			set
			{
				if (value.HasValue)
					Entity.Attributes[Fields.MonthOfYear] = new OptionSetValue((int)value.Value);
				else
					Entity.Attributes[Fields.MonthOfYear] = null;
			}
		}

		/// <summary>
		/// <para>Date of the next expanded instance of a recurring appointment series.</para>
		/// <para>ReadOnly - DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Next Expanded Instance Date</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? NextExpansionInstanceDateUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.NextExpansionInstanceDate); }
		}

		/// <summary>
		/// <para>Number of appointment occurrences in a recurring appointment series.</para>
		/// <para>Integer - MinValue: 1 - MaxValue: 999</para>
		/// <para>Occurrences</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? Occurrences
		{
			get { return Entity.GetAttributeValue<int?>(Fields.Occurrences); }
			set { Entity.Attributes[Fields.Occurrences] = value; }
		}

		/// <summary>
		/// <para>Enter the account, contact, lead, user, or other equipment resources that are not needed at the recurring appointment, but can optionally attend.</para>
		/// <para>PartyList</para>
		/// <para>Optional Attendees</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public System.Collections.Generic.List<ActivityParty> OptionalAttendees
		{
			get
			{
				var data = new System.Collections.Generic.List<ActivityParty>();
				foreach (var item in Entity.GetAttributeValue<EntityCollection>(Fields.OptionalAttendees).Entities)
					data.Add(new ActivityParty(item));
				return data;
			}
			set
			{
				var data = new EntityCollection();
				foreach (var item in value)
					data.Entities.Add(item.Entity);
				Entity.Attributes[Fields.OptionalAttendees] = data;
			}
		}

		/// <summary>
		/// <para>Enter the user who is in charge of coordinating or leading the recurring appointment to make sure the appointment is displayed in the user's My Activities view.</para>
		/// <para>PartyList</para>
		/// <para>Organizer</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public System.Collections.Generic.List<ActivityParty> Organizer
		{
			get
			{
				var data = new System.Collections.Generic.List<ActivityParty>();
				foreach (var item in Entity.GetAttributeValue<EntityCollection>(Fields.Organizer).Entities)
					data.Add(new ActivityParty(item));
				return data;
			}
			set
			{
				var data = new EntityCollection();
				foreach (var item in value)
					data.Entities.Add(item.Entity);
				Entity.Attributes[Fields.Organizer] = data;
			}
		}

		/// <summary>
		/// <para>Unique identifier of the Microsoft Office Outlook recurring appointment series owner that correlates to the PR_OWNER_APPT_ID MAPI property.</para>
		/// <para>Integer - MinValue: -2,147,483,648 - MaxValue: 2,147,483,647</para>
		/// <para>Outlook Recurring Appointment Master Owner</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? OutlookOwnerApptId
		{
			get { return Entity.GetAttributeValue<int?>(Fields.OutlookOwnerApptId); }
			set { Entity.Attributes[Fields.OutlookOwnerApptId] = value; }
		}

		/// <summary>
		/// <para>Date and time that the record was migrated.</para>
		/// <para>DateTimeBehavior: UserLocal - DateTimeFormat: DateOnly</para>
		/// <para>Record Created On</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? OverriddenCreatedOnUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.OverriddenCreatedOn); }
			set { Entity.Attributes[Fields.OverriddenCreatedOn] = value; }
		}

		/// <summary>
		/// <para>Enter the user or team who is assigned to manage the record. This field is updated every time the record is assigned to a different user.</para>
		/// <para>Owner</para>
		/// <para>Owner</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference OwnerId
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.OwnerId); }
			set { Entity.Attributes[Fields.OwnerId] = value; }
		}

		/// <summary>
		/// <para>Unique identifier of the business unit that owns the recurring appointment series.</para>
		/// <para>ReadOnly - Lookup to businessunit</para>
		/// <para>Owning Business Unit</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference OwningBusinessUnit
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.OwningBusinessUnit); }
		}

		/// <summary>
		/// <para>Unique identifier of the team who owns the recurring appointment series.</para>
		/// <para>ReadOnly - Lookup to team</para>
		/// <para>Owning Team</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference OwningTeam
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.OwningTeam); }
		}

		/// <summary>
		/// <para>Unique identifier of the user who owns the recurring appointment series.</para>
		/// <para>ReadOnly - Lookup to systemuser</para>
		/// <para>Owning User</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference OwningUser
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.OwningUser); }
		}

		/// <summary>
		/// <para>End date of the recurrence range.</para>
		/// <para>DateTimeBehavior: UserLocal - DateTimeFormat: DateOnly</para>
		/// <para>Recurrence Range End</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? PatternEndDateUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.PatternEndDate); }
			set { Entity.Attributes[Fields.PatternEndDate] = value; }
		}

		/// <summary>
		/// <para>Select the type of end date for the recurring appointment, such as no end date or the number of occurrences.</para>
		/// <para>Picklist</para>
		/// <para>Pattern End Type</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.PatternEndType? PatternEndType
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.PatternEndType);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.PatternEndType)value.Value;
			}
			set
			{
				if (value.HasValue)
					Entity.Attributes[Fields.PatternEndType] = new OptionSetValue((int)value.Value);
				else
					Entity.Attributes[Fields.PatternEndType] = null;
			}
		}

		/// <summary>
		/// <para>Start date of the recurrence range.</para>
		/// <para>Required - DateTimeBehavior: UserLocal - DateTimeFormat: DateOnly</para>
		/// <para>Recurrence Range Start</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? PatternStartDateUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.PatternStartDate); }
			set { Entity.Attributes[Fields.PatternStartDate] = value; }
		}

		/// <summary>
		/// <para>Select the priority so that preferred customers or critical issues are handled quickly.</para>
		/// <para>Picklist</para>
		/// <para>Priority</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.PriorityCode? PriorityCode
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.PriorityCode);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.PriorityCode)value.Value;
			}
			set
			{
				if (value.HasValue)
					Entity.Attributes[Fields.PriorityCode] = new OptionSetValue((int)value.Value);
				else
					Entity.Attributes[Fields.PriorityCode] = null;
			}
		}

		/// <summary>
		/// <para>Shows the ID of the process.</para>
		/// <para>Uniqueidentifier</para>
		/// <para>Process</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Guid? ProcessId
		{
			get { return Entity.GetAttributeValue<Guid?>(Fields.ProcessId); }
			set { Entity.Attributes[Fields.ProcessId] = value; }
		}

		/// <summary>
		/// <para>Select the pattern type for the recurring appointment to indicate whether the appointment occurs daily, weekly, monthly, or yearly.</para>
		/// <para>Picklist</para>
		/// <para>Recurrence Frequency</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.RecurrencePatternType? RecurrencePatternType
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.RecurrencePatternType);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.RecurrencePatternType)value.Value;
			}
			set
			{
				if (value.HasValue)
					Entity.Attributes[Fields.RecurrencePatternType] = new OptionSetValue((int)value.Value);
				else
					Entity.Attributes[Fields.RecurrencePatternType] = null;
			}
		}

		/// <summary>
		/// <para>Choose the record that the recurring appointment series relates to.</para>
		/// <para>Lookup to account;contact;devkit_azureaccount;devkit_webapi;knowledgearticle;knowledgebaserecord</para>
		/// <para>Regarding</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference RegardingObjectId
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.RegardingObjectId); }
			set { Entity.Attributes[Fields.RegardingObjectId] = value; }
		}

		/// <summary>
		/// <para>Enter the account, contact, lead, user, or other equipment resources that are required to attend the recurring appointment.</para>
		/// <para>PartyList</para>
		/// <para>Required Attendees</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public System.Collections.Generic.List<ActivityParty> RequiredAttendees
		{
			get
			{
				var data = new System.Collections.Generic.List<ActivityParty>();
				foreach (var item in Entity.GetAttributeValue<EntityCollection>(Fields.RequiredAttendees).Entities)
					data.Add(new ActivityParty(item));
				return data;
			}
			set
			{
				var data = new EntityCollection();
				foreach (var item in value)
					data.Entities.Add(item.Entity);
				Entity.Attributes[Fields.RequiredAttendees] = data;
			}
		}

		/// <summary>
		/// <para>Unique identifier of the recurrence rule that is associated with the recurring appointment series.</para>
		/// <para>ReadOnly - Lookup to recurrencerule</para>
		/// <para>Recurrence Rule</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference RuleId
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.RuleId); }
		}

		/// <summary>
		/// <para>Scheduled end time of the recurring appointment series.</para>
		/// <para>ReadOnly - DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>End Time</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? ScheduledEndUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.ScheduledEnd); }
		}

		/// <summary>
		/// <para>Scheduled start time of the recurring appointment series.</para>
		/// <para>ReadOnly - DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Start Time</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? ScheduledStartUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.ScheduledStart); }
		}

		/// <summary>
		/// <para>Indicates whether the recurring appointment series is active or inactive.</para>
		/// <para>Boolean</para>
		/// <para>Series Status</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public bool? SeriesStatus
		{
			get { return Entity.GetAttributeValue<bool?>(Fields.SeriesStatus); }
			set { Entity.Attributes[Fields.SeriesStatus] = value; }
		}

		/// <summary>
		/// <para>Shows the date and time by which the activities are sorted.</para>
		/// <para>DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Sort Date</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? SortDateUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.SortDate); }
			set { Entity.Attributes[Fields.SortDate] = value; }
		}

		/// <summary>
		/// <para>Shows the ID of the stage.</para>
		/// <para>Uniqueidentifier</para>
		/// <para>(Deprecated) Process Stage</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Guid? StageId
		{
			get { return Entity.GetAttributeValue<Guid?>(Fields.StageId); }
			set { Entity.Attributes[Fields.StageId] = value; }
		}

		/// <summary>
		/// <para>Start time of the recurring appointment series.</para>
		/// <para>DateTimeBehavior: UserLocal - DateTimeFormat: DateAndTime</para>
		/// <para>Pattern Start Time</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public DateTime? StartTimeUtc
		{
			get { return Entity.GetAttributeValue<DateTime?>(Fields.StartTime); }
			set { Entity.Attributes[Fields.StartTime] = value; }
		}

		/// <summary>
		/// <para>Shows whether the recurring appointment is open, scheduled, completed, or canceled. Completed and canceled appointments are read-only and can't be edited.</para>
		/// <para>State</para>
		/// <para>Status</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.StateCode? StateCode
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.StateCode);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.StateCode)value.Value;
			}
			set
			{
				if (value.HasValue)
					Entity.Attributes[Fields.StateCode] = new OptionSetValue((int)value.Value);
				else
					Entity.Attributes[Fields.StateCode] = null;
			}
		}

		/// <summary>
		/// <para>Select the recurring appointment's status.</para>
		/// <para>Status</para>
		/// <para>Status Reason</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.StatusCode? StatusCode
		{
			get
			{
				var value = Entity.GetAttributeValue<OptionSetValue>(Fields.StatusCode);
				if (value == null) return null;
				return (Dev.DevKit.Shared.Entities.RecurringAppointmentMasterOptionSets.StatusCode)value.Value;
			}
			set
			{
				if (value.HasValue)
					Entity.Attributes[Fields.StatusCode] = new OptionSetValue((int)value.Value);
				else
					Entity.Attributes[Fields.StatusCode] = null;
			}
		}

		/// <summary>
		/// <para>Type a subcategory to identify the recurring appointment type and relate the activity to a specific product, sales region, business group, or other function.</para>
		/// <para>String - MaxLength: 250</para>
		/// <para>Sub-Category</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string Subcategory
		{
			get { return Entity.GetAttributeValue<string>(Fields.Subcategory); }
			set { Entity.Attributes[Fields.Subcategory] = value; }
		}

		/// <summary>
		/// <para>Type a short description about the objective or primary topic of the recurring appointment.</para>
		/// <para>Required - String - MaxLength: 200</para>
		/// <para>Subject</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string Subject
		{
			get { return Entity.GetAttributeValue<string>(Fields.Subject); }
			set { Entity.Attributes[Fields.Subject] = value; }
		}

		/// <summary>
		/// <para>For internal use only.</para>
		/// <para>Uniqueidentifier</para>
		/// <para></para>
		/// </summary>
		[DebuggerNonUserCode()]
		public Guid? SubscriptionId
		{
			get { return Entity.GetAttributeValue<Guid?>(Fields.SubscriptionId); }
			set { Entity.Attributes[Fields.SubscriptionId] = value; }
		}

		/// <summary>
		/// <para>For internal use only.</para>
		/// <para>Integer - MinValue: -1 - MaxValue: 2,147,483,647</para>
		/// <para></para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? TimeZoneRuleVersionNumber
		{
			get { return Entity.GetAttributeValue<int?>(Fields.TimeZoneRuleVersionNumber); }
			set { Entity.Attributes[Fields.TimeZoneRuleVersionNumber] = value; }
		}

		/// <summary>
		/// <para>Choose the local currency for the record to make sure budgets are reported in the correct currency.</para>
		/// <para>Lookup to transactioncurrency</para>
		/// <para>Currency</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public EntityReference TransactionCurrencyId
		{
			get { return Entity.GetAttributeValue<EntityReference>(Fields.TransactionCurrencyId); }
			set { Entity.Attributes[Fields.TransactionCurrencyId] = value; }
		}

		/// <summary>
		/// <para>For internal use only.</para>
		/// <para>String - MaxLength: 1250</para>
		/// <para>(Deprecated) Traversed Path</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public string TraversedPath
		{
			get { return Entity.GetAttributeValue<string>(Fields.TraversedPath); }
			set { Entity.Attributes[Fields.TraversedPath] = value; }
		}

		/// <summary>
		/// <para>Time zone code that was in use when the record was created.</para>
		/// <para>Integer - MinValue: -1 - MaxValue: 2,147,483,647</para>
		/// <para>UTC Conversion Time Zone Code</para>
		/// </summary>
		[DebuggerNonUserCode()]
		public int? UTCConversionTimeZoneCode
		{
			get { return Entity.GetAttributeValue<int?>(Fields.UTCConversionTimeZoneCode); }
			set { Entity.Attributes[Fields.UTCConversionTimeZoneCode] = value; }
		}

		/// <summary>
		/// <para>ReadOnly - BigInt</para>
		/// <para></para>
		/// </summary>
		[DebuggerNonUserCode()]
		public long? VersionNumber
		{
			get { return Entity.GetAttributeValue<long?>(Fields.VersionNumber); }
		}
	}
}
